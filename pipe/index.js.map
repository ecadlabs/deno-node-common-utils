{"version":3,"sources":["index.ts"],"sourcesContent":["/*******************************************************************************\n * Fn Type\n *\n * Represents a function with arbitrary arity of arguments\n ******************************************************************************/\nexport type Fn<AS extends unknown[], B> = (...as: AS) => B;\n\n/*******************************************************************************\n * UnknownFn Type\n *\n * Represents a function with unknown unputs and output\n ******************************************************************************/\nexport type UnknownFn = Fn<unknown[], unknown>;\n\n/**\n * Apply1\n *\n * A special case of apply for functions that only take a single argument\n */\nexport const apply1 = <A, B>(a: A, fn: Fn<[A], B>): B => fn(a);\n\n/**\n * Pipe\n *\n * The pipe takes a value as the first argument and composes it with subsequent\n * function arguments, returning the result of the last function passed in\n *\n * Original pipe function pulled from fp-ts and modified\n * https://github.com/gcanti/fp-ts/blob/master/src/pipeable.ts\n */\nexport type PipeFn = {\n\t<A>(a: A): A;\n\t<A, B>(a: A, ab: (a: A) => B): B;\n\t<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C;\n\t<A, B, C, D>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t): D;\n\t<A, B, C, D, E>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t): E;\n\t<A, B, C, D, E, F>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t\tef: (e: E) => F,\n\t): F;\n\t<A, B, C, D, E, F, G>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t\tef: (e: E) => F,\n\t\tfg: (f: F) => G,\n\t): G;\n\t<A, B, C, D, E, F, G, H>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t\tef: (e: E) => F,\n\t\tfg: (f: F) => G,\n\t\tgh: (g: G) => H,\n\t): H;\n\t<A, B, C, D, E, F, G, H, I>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t\tef: (e: E) => F,\n\t\tfg: (f: F) => G,\n\t\tgh: (g: G) => H,\n\t\thi: (h: H) => I,\n\t): I;\n\t<A, B, C, D, E, F, G, H, I, J>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t\tef: (e: E) => F,\n\t\tfg: (f: F) => G,\n\t\tgh: (g: G) => H,\n\t\thi: (h: H) => I,\n\t\tij: (i: I) => J,\n\t): J;\n\t<A, B, C, D, E, F, G, H, I, J, K>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t\tef: (e: E) => F,\n\t\tfg: (f: F) => G,\n\t\tgh: (g: G) => H,\n\t\thi: (h: H) => I,\n\t\tij: (i: I) => J,\n\t\tjk: (j: J) => K,\n\t): K;\n\t<A, B, C, D, E, F, G, H, I, J, K, L>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t\tef: (e: E) => F,\n\t\tfg: (f: F) => G,\n\t\tgh: (g: G) => H,\n\t\thi: (h: H) => I,\n\t\tij: (i: I) => J,\n\t\tjk: (j: J) => K,\n\t\tkl: (K: K) => L,\n\t): L;\n\t<A, B, C, D, E, F, G, H, I, J, K, L>(\n\t\ta: A,\n\t\tab: (a: A) => B,\n\t\tbc: (b: B) => C,\n\t\tcd: (c: C) => D,\n\t\tde: (d: D) => E,\n\t\tef: (e: E) => F,\n\t\tfg: (f: F) => G,\n\t\tgh: (g: G) => H,\n\t\thi: (h: H) => I,\n\t\tij: (i: I) => J,\n\t\tjk: (j: J) => K,\n\t\tkl: (K: K) => L,\n\t\tend: never,\n\t): L;\n};\n\nexport const pipe: PipeFn = (a: unknown, ...fns: UnknownFn[]): unknown => fns.reduce(apply1, a);\n"],"mappings":";AAmBO,IAAM,SAAS,CAAO,GAAM,OAAsB,GAAG,CAAC;AA0HtD,IAAM,OAAe,CAAC,MAAe,QAA8B,IAAI,OAAO,QAAQ,CAAC;","names":[]}